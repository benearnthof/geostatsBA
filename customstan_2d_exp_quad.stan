//lets try swapping out the covariance function for an equivalent 2d case
//data generated by make_standata
data {
  int<lower=1> N;  // number of observations
  vector[N] Y;  // response variable
  // data related to GPs
  // number of sub-GPs (equal to 1 unless 'by' was used)
  int<lower=1> Kgp_1;
  int<lower=1> Dgp_1;  // GP dimension
  // covariates of the GP
  vector[Dgp_1] Xgp_1[N];  // array of size N containing vectors of length Dgp_1
  int prior_only;  // should the likelihood be ignored?
}
transformed data {
  real delta = 1e-9; // delta for positive definite covariance matrix
}

/*parameters {
  real<lower=0> rho; // scale parameter
  real<lower=0> alpha; // sigma parameter for diagonals
  real<lower=0> sigma; // residual SD
  vector[N] eta; // residual mean
}*/

parameters {
  // temporary intercept for centered predictors
  real Intercept;
  // GP standard deviation parameters
  vector<lower=0>[Kgp_1] sdgp_1; // vector of size number of subGPs = 1
  // GP length-scale parameters
  vector<lower=0>[1] lscale_1[Kgp_1]; // array of size Kgp_1 containing vectors of length 1
  // latent variables of the GP
  vector[N] zgp_1; // residual mean
  real<lower=0> sigma;  // residual SD
}

transformed parameters {
  // we define gaussian process through f, brms defines it in function block
  vector[N] f;
  {
    matrix[N, N] chol;
    //matrix[N, N] K = cov_exp_quad(x, alpha, rho);
    int Dls = rows(lscale_1[1]);
    // size returns top level number of elements; equal to N
    int Nnew = size(Xgp_1);
    matrix[Nnew, Nnew] cov;
    
    if (Dls == 1) {
      // one dimensional or isotropic GP
      // cov = cov_exp_quad(x[, 1], sdgp, lscale[1])
      for (i in 1:Nnew) {
      cov[i, i] = sdgp_1[1] * sdgp_1[1];
      }
      for (i in 1:Nnew) {
        for (j in (i+1):Nnew) {
          real sq_alpha = sdgp_1[1] * sdgp_1[1]; //square alpha
          real sq_dist = (Xgp_1[i,1] - Xgp_1[j,1]) *  (Xgp_1[i,1] - Xgp_1[j,1]);
          // real sq_dist = (Xgp_1[,i] - Xgp_1[,j]) * (Xgp_1[,i] - Xgp_1[,j]); //squared euclidian dist
          cov[i,j] = sq_alpha * exp(-(sq_dist/(lscale_1[1,1] * lscale_1[1,1]))); //squared exponential cov
          cov[j,i] = cov[i, j]; //symmetric matrix
        }
      }
      
    } else {
      // multi-dimensional non-isotropic GP
      // cov = cov_exp_quad(x[, 1], sdgp, lscale[1]);
      for (i in 1:Nnew) {
      cov[i, i] = sdgp_1[1] * sdgp_1[1];
      }
      for (i in 1:Nnew) {
        for (j in (i+1):Nnew) {
          real sq_alpha = sdgp_1[1] * sdgp_1[1]; //square alpha
          real sq_dist = (Xgp_1[i,1] - Xgp_1[j,1]) *  (Xgp_1[i,1] - Xgp_1[j,1]);
          // real sq_dist = (Xgp_1[,i] - Xgp_1[,j]) * (Xgp_1[,i] - Xgp_1[,j]); //squared euclidian dist
          cov[i,j] = sq_alpha * exp(-(sq_dist/(lscale_1[1,1] * lscale_1[1,1]))); //squared exponential cov
          cov[j,i] = cov[i, j]; //symmetric matrix
        }
      }
      for (d in 2:Dls) {
        // cov = cov .* cov_exp_quad(x[, d], 1, lscale[d]);
        // do everything again, try to wrap in function later
        matrix[Nnew, Nnew] cov_tmp; 
        for (i in 1:Nnew) {
          cov_tmp[i, i] = sdgp_1[1] * sdgp_1[1];
        }
        // loop for cov_tmp
        for (i in 1:Nnew) {
          for (j in (i+1):Nnew) {
            real sq_alpha = sdgp_1[1] * sdgp_1[1]; //square alpha
            real sq_dist = (Xgp_1[i,d] - Xgp_1[j,d]) *  (Xgp_1[i,d] - Xgp_1[j,d]);
            // technically need lscale_1[1,d] here but we only have one gp and one lscale
            cov_tmp[i,j] = sq_alpha * exp(-(sq_dist/(lscale_1[1,1] * lscale_1[1,1]))); //squared exponential cov
            cov_tmp[j,i] = cov[i, j]; //symmetric matrix
          }
        }
        cov = cov .* cov_tmp;
      }
    }
    // making sure matrix is positive definite for cholesky
    for (n in 1:N) {
      cov[n, n] = cov[n, n] + delta;
    }
    chol = cholesky_decompose(cov);
    f = chol * zgp_1;
  }
}
model {
  // initialize linear predictor term
  // gp returns product of chol and zgp_1 
  // vector[N] mu = Intercept + rep_vector(0, N) + gp(Xgp_1, sdgp_1[1], lscale_1[1], zgp_1);
  vector[N] mu = Intercept + rep_vector(0, N) + f;
  // priors including all constants
  target += student_t_lpdf(Intercept | 3, 7, 10);
  target += student_t_lpdf(sdgp_1 | 3, 0, 10) - 1 * student_t_lccdf(0 | 3, 0, 10);
  target += normal_lpdf(zgp_1 | 0, 1);
  target += inv_gamma_lpdf(lscale_1[1] | 1.089792, 0.015279);
  target += student_t_lpdf(sigma | 3, 0, 10) - 1 * student_t_lccdf(0 | 3, 0, 10);
  // likelihood including all constants
  if (!prior_only) {
    target += normal_lpdf(Y | mu, sigma);
  }
  /*lscale_1[1] ~ inv_gamma(1.089792, 0.015279);
  sdgp_1 ~ std_normal();
  sigma ~ std_normal();
  zgp_1 ~ std_normal(); */ 
  //Y ~ normal(f[1:N1], sigma);
}
generated quantities {
  // actual population-level intercept
  real b_Intercept = Intercept;
  vector[N] mu_generated = Intercept + rep_vector(0, N) + f;
}
