//lets try swapping out the covariance function for an equivalent 2d case
//data generated by make_standata
data {
  int<lower=1> N;  // number of observations
  vector[N] Y;  // response variable
  // data related to GPs
  // number of sub-GPs (equal to 1 unless 'by' was used)
  int<lower=1> Kgp_1;
  int<lower=1> Dgp_1;  // GP dimension
  // covariates of the GP
  vector[Dgp_1] Xgp_1[N];  // array of size N containing vectors of length Dgp_1
  int prior_only;  // should the likelihood be ignored?
}
transformed data {
}

/*parameters {
  real<lower=0> rho; // scale parameter
  real<lower=0> alpha; // sigma parameter for diagonals
  real<lower=0> sigma; // residual SD
  vector[N] eta; // residual mean
}*/

parameters {
  // temporary intercept for centered predictors
  real Intercept;
  // GP standard deviation parameters
  vector<lower=0>[Kgp_1] sdgp_1; // vector of size number of subGPs = 1
  // GP length-scale parameters
  vector<lower=0>[1] lscale_1[Kgp_1]; // array of size Kgp_1 containing vectors of length 1
  // latent variables of the GP
  vector[N] zgp_1; // residual mean
  real<lower=0> sigma;  // residual SD
}

transformed parameters {
  // we define gaussian process through f, brms defines it in function block
  vector[N] f;
  {
    matrix[N, N] chol;
    //matrix[N, N] K = cov_exp_quad(x, alpha, rho);
    int Dls = rows(lscale_1[1]);
    // size returns top level number of elements; equal to N
    int Nnew = size(Xgp_1);
    matrix[Nnew, Nnew] cov;
    
    if (Dls == 1) {
      // one dimensional or isotropic GP
      // cov = cov_exp_quad(x[, 1], sdgp, lscale[1])
      for (i in 1:Nnew) {
      cov[i, i] = sdgp_1[1] * sdgp_1[1];
      }
      for (i in 1:Nnew) {
        for (j in (i+1):Nnew) {
          real sq_alpha = sdgp_1[1] * sdgp_1[1]; //square alpha
          real sq_dist = (Xgp_1[i,1] - Xgp_1[j,1]) *  (Xgp_1[i,1] - Xgp_1[j,1]);
          // real sq_dist = (Xgp_1[,i] - Xgp_1[,j]) * (Xgp_1[,i] - Xgp_1[,j]); //squared euclidian dist
          cov[i,j] = sq_alpha * exp(-(sq_dist/(lscale_1[1,1] * lscale_1[1,1]))); //squared exponential cov
          cov[j,i] = cov[i, j]; //symmetric matrix
        }
      }
      
    } else {
      // multi-dimensional non-isotropic GP
      // cov = cov_exp_quad(x[, 1], sdgp, lscale[1]);
      for (i in 1:Nnew) {
      cov[i, i] = sdgp_1[1] * sdgp_1[1];
      }
      for (i in 1:Nnew) {
        for (j in (i+1):Nnew) {
          real sq_alpha = sdgp_1[1] * sdgp_1[1]; //square alpha
          real sq_dist = (Xgp_1[i,1] - Xgp_1[j,1]) *  (Xgp_1[i,1] - Xgp_1[j,1]);
          // real sq_dist = (Xgp_1[,i] - Xgp_1[,j]) * (Xgp_1[,i] - Xgp_1[,j]); //squared euclidian dist
          cov[i,j] = sq_alpha * exp(-(sq_dist/(lscale_1[1,1] * lscale_1[1,1]))); //squared exponential cov
          cov[j,i] = cov[i, j]; //symmetric matrix
        }
      }
      for (d in 2:Dls) {
        // cov = cov .* cov_exp_quad(x[, d], 1, lscale[d]);
        
      }
    
    //diagonal elements
    /*for (i in 1:N) {
      K[i, i] = alpha * alpha;
    }
    for (i in 1:N) {
      for (j in (i+1):N) {
        real sq_alpha = alpha * alpha; //square alpha
        real sq_dist = (x[i] - x[j]) * (x[i] - x[j]); //squared euclidian dist
        K[i,j] = sq_alpha * exp(-(sq_dist/(rho * rho))); //squared exponential cov
        K[j,i] = K[i, j]; //symmetric matrix
      }
    }
    */
    
    // making sure matrix is positive definite for cholesky
    for (n in 1:N) {
      K[n, n] = K[n, n] + delta;
    }
    chol = cholesky_decompose(K);
    f = chol * zgp_1;
  }
}
model {
  lscale_1 ~ inv_gamma(5, 5);
  sdgp_1 ~ std_normal();
  sigma ~ std_normal();
  zgp_1 ~ std_normal();

  y1 ~ normal(f[1:N1], sigma);
}
generated quantities {
  vector[N2] y2;
  for (n2 in 1:N2)
    y2[n2] = normal_rng(f[N1 + n2], sigma);
}
